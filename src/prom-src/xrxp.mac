;
; Xerox 820 ROM-based monitor version 2.0, Disassembled by K1BC
;

	.Z80			; Use Zilog format ops
	INCLUDE	xrxpdef.mac	; Get the parameters

SIO.CS equ SIO.AS
SIO.CD equ SIO.AD
BRG.C equ BRG.A

; This program is copied from ROM to RAM at power clear. There is an LDIR
; at the beginning of the ROM which moves this code, then jumps to
; location F000.

; Here is the mover routine:

	ASEG
        IFDEF AS_COM
	ORG	0100H
        ELSE
	ORG	0
        ENDIF

MOVER:	DI			; Interrupts off
	LD HL,	MOVER+00010H	; Where following code lives (in ROM or COM-loader)
	LD DE,	0F000H		; Where we want it in RAM
	LD BC,	01000H		; How much we want to move (should be 0FF0)
	LDIR			; Move that code
	JP	0F000H		; Go to cold start entry

	DB	00H		; Even 16-byte boundary filler

        .PHASE	0F000H          ; Final running location of this monitor
				; Location in EPROM is 0010H in shadow
				;  space. 0000-000F are the LDIR/JP thing.

;First is an entry vector for common routines.

VINIT:	JP	INIT		; Cold start entry
VPROMP:	JP	PROMPT		; Warm restart entry
VCONST:	JP	CONST		; Check keyboard status
VCONIN:	JP	CONIN		; Input char from keyboard
VCRTOU:	JP	CRTOUT		; Type char on CRT
V2CRTO:	JP	CRTOUT		; Second copy of above, for some reason
VSIOST:	JP	SIOST		; Check status of serial port input
VSIOIN:	JP	SIOIN		; Read char from serial port
VSIOOU:	JP	SIOOUT		; Write char to serial port
VSELEC:	JP	SELECT		; Select a Floppy drive
VHOME:	JP	HOME		; Home/recalibrate current floppy
VSEEK:	JP	SEEK		; Seek cylinder on floppy
VREAD:	JP	READ		; Read sector from floppy
VWRITE:	JP	WRITE		; Write sector to floppy
VHDUMP:	JP	HDUMP		; Hex dump routine, dumps RAM
VHWDOU:	JP	HWDOUT		; Type one word in hex and a space
VHOUSP:	JP	HOUTSP		; Type one hex byte and a space
VSPACE:	JP	SPACE		; Type a space
VCHOUT:	JP	CHOUT		; Type a character
VCRLFS:	JP	CRLFSP		; Type a CR, LF and space
VTYIUC:	JP	TYIUC		; Type in a char and raise lower case
VASCHX:	JP	ASCHEX		; Convert ASCII 0-9, A-f to 4-bit hex
VPSOUT:	JP	PSOUT		; Type string, inline after call, ^D terminated

; Cold start entry point of monitor. Clear high RAM, set initial variables,
; set up I/O chips and interrupt system, the enter command routine.

INIT:	DI			; Start with interrupts off
	LD HL,	ZEND		; Clear upper RAM variable area
INITZL:	LD (HL),0
	LD SP,	HL              ; SP winds up at FF01 after loop
	DEC	L		; Loop over high RAM page
	JR NZ,	INITZL		; ..
	LD HL,	INIV		; Set up initial RAM variables
INITRL:	LD B,	0               ; Small count
	LD C,	(HL)		;  of a block to copy
	INC	HL		; Get address to be set up
	LD E,	(HL)
	INC	HL
	LD D,	(HL)
	INC	HL		; Point at data to put in variables
	LDIR			; Copy data
	BIT B7,	(HL)		; Check for end of setup blocks
	JR Z,	INITRL		; Loop over setups
	INC	HL		; Pass over end marker
INIIOL:	LD B,	(HL)		; Get count of I/O setup data bytes
	INC	HL
	LD C,	(HL)            ; To be stuffed into this I/O port
	INC	HL		; Point at data bytes
	OTIR			; Set up the I/O device
	BIT B7,	(HL)		; Check for end of setup blocks
	JR Z,	INIIOL		; Loop over all I/O setups
	LD A,	IOPAGE		; I/O vector page is at FF00
	LD I,	A		; Set processor for vectored interrupts
	IM	2
	IN A,	(PIO.SD)        ; Check for five or eight inch drives
	BIT B4,	A		; ..
	JR Z,	IFIVE		; Go for five
	LD A,	2		; If it's eight,
       	LD (FDSTEP),A		; Change step rate
IFIVE:	EI                      ; OK to turn on interrupts now
	CALL	PSOUT		; Greet the morning
	DB	CH.SUB          ; Clear the screen
	DB	'...XEROX 820  VER. 2023..'
	DB	CH.CR,CH.LF
	DB	'   A - BOOT SYSTEM'
	DB	CH.CR,CH.LF
	DB	'   T - TYPEWRITER'
	DB	CH.CR,CH.LF,CH.EOT

	IFDEF   AUTOBT
DLAY:
	LD 	A,2
	LD	(FDRUNT),A
DLAY1:	CALL	POKEF1
	LD 	A,(FDRUNT)
	AND	0FFH
	JR NZ,	DLAY1

	CALL	ACMD  		; do an autoboot for the sophisticated usr
	CALL	PSOUT		; print an error message if boot fails
	DB	CH.CR,CH.LF
	DB	'Disk in A? Enter A <CR> to boot CP/M'
	DB	CH.CR,CH.LF,CH.EOT
	ENDIF

	JP	VPROMP		; Go to warm boot entry for commands

; Initialization table. First, initializers for RAM variables.
; Organized for copying loop above, these are in the form:
;   one byte of count
;   one word of where to put the bytes
;   n bytes of data to put there
; followed by another block, or "FF" to mark the end of the list

INIV:

;First are the interrupt vector handler pointers

        DB	2
	DW	IOINTS+IV.KBD
	DW      KBDINT          ; Handler for keyboard

	DB	2
	DW	IOINTS+IV.CLK
	DW      CLKINT          ; Handler for clock

	DB	2
	DW	IOINTS+IV.CTC
	DW      CTCINT          ; Handler for counter/timer

	DB	11              ; Drive and cylinder history
	DW	FDDRV		;  all set to "unknown"
	DB	FF              ; For FDDRV
	DB	FF              ; For CYLVEC
	DB	FF
	DB	FF
	DB	FF
	DB	FF
	DB	FF
	DB	FF
	DB	003H		; For FDSTEP
	DB	SECSIZ		; For FDSSIZ
	DB	WHIRTM		; For FDRUNT

	DB	1
	DW	SPCCRS          ; Cursor char if on a space
	DB	2               ;  is this char

	DB	2
	DW	TFF7A		; F0E9 7A FF (remnant????)
	DB	0
	DB	1

	DB	FF              ; End of RAM initilizer list

; More initialization table: Now the I/O port initialization values.
; Organized for copying loop above, these are in the form:
;   one byte count
;   one byte port number
;   n bytes of port initialization values
; followed by another block, or "FF" to mark the end of the list

INIVIO:	DB	3
	DB	PIO.SC          ; PIO for system control port
	DB	0CFH
	DB	038H
	DB	040H

	DB	1
	DB	PIO.SD
	DB	0

	DB	3
	DB	PIO.KC          ; PIO control for keyboard
	DB	04FH
	DB	IV.KBD          ; Vector location
	DB	083H

	DB	1
	DB	CTC.C0          ; Chan 0 of CTC
	DB	IV.CT0

	DB	2
	DB	CTC.C2          ; Chan 2 of CTC
	DB	027H
	DB	069H

	DB	2
	DB	CTC.C3          ; Chan 3 of CTC
	DB	0C7H
	DB	05DH

	DB	10
	DB	SIO.BS          ; Channel B of SIO
	DB	004H
	DB	045H
	DB	001H
	DB	004H
	DB	003H
	DB	041H
	DB	005H
	DB	02AH
	DB	002H
	DB	000H

	DB	1
	DB	BRG.B           ; Set serial port baud rate
	DB	5               ; 300 Baud for SIO channel B

        ;; console channel -- might be A or B
	DB	6
	DB	SIO.CS          ; Channel C (might be A or B) of SIO
	DB	004H, 044H      ; no parity, 1 stop bit
	;DB	001H, 004H      ; (interrupts - channel B only)
	DB	003H, 0C1H      ; RX 8 bits, RX-enable
	DB	005H, 06AH      ; TX 8 bits, TX-enable, RTS-enable
	;DB	002H, 000H      ; (interrupts - channel B only)

	DB	1
	DB	BRG.C           ; Set serial port baud rate
	DB	0FH             ; 19200 Baud for SIO channel A


	DB	FF              ; End of I/O initializer list

PROMPT:	CALL	PSOUT		; Prompt for a command
	DB      CH.CR,CH.LF,'* ',CH.EOT
	LD HL,	CMDBUF          ; Read a command line into this buffer
	LD C,	NCMDBF          ; Size of command buffer
	CALL	PSIN            ; Collect a string
	JR C,	CMDERR		; Error if too long (!)
	XOR	A               ; Nothing typed in during typeout, yet
	LD (PAUSCH),A           ; ..
	CALL	CRLFSP		; Go to new line
	LD A,	(CMDBUF)        ; First char of command
	CP      CH.CR           ; Blank line?
	JR Z,	PROMPT		; If so, just prompt for another
	LD HL,	CMDTAB		; Look up first char of command in table
	LD BC,	NCMDT		; Table length
	CALL	CDISP		; Find it
	JR NZ,	CMDERR		; Error if not found
	PUSH	BC		; Save handler address
	LD IY,	CMDBF1		; Point at possible command parameters
	CALL	CMARGS		; Parse any args, Number of args into reg A
	POP	IX		; Handler for command
	JR C,	CMDERR		; Failure in arg parser?
	LD HL,	(ARG1)		; Load three args into register pairs
	LD DE,	(ARG2)		; Where handlers can get them easily
	LD BC,	(ARG3)
	CALL	GOHAND          ; Go to the handlers
	JR NC,	PROMPT		; If they return NC, go back for more
CMDERR:	CALL	PSOUT		; Command error message
	DB	' what ?',CH.EOT
	JR	PROMPT		; Back for another command

GOHAND:	JP	(IX)		; Dispatch to command

CMDTAB:	DB	'TVROIGXFMCBDA' ; Legal command letters
NCMDT   EQU     $-CMDTAB        ; Table length

	DW	ACMD		; Handlers for those letters
	DW	DCMD		; In reverse order, for dispatcher
	DW	BCMD
	DW	CCMD
	DW	MCMD
	DW	FCMD
	DW	XCMD
	DW	GCMD
	DW	ICMD
	DW	OCMD
	DW	RCMD
	DW	VCMD
	DW	TCMD

; Handlers for monitor commands.

; "A" command - Boot system from drive A

ACMD:	LD C,	0               ; Drive is number zero
ACMD1:	CALL	SELECT		; Select the drive
	JR NZ,	DSKERR		; Give error msg if can't get it
	CALL	HOME		; Seek track 0 of the drive
	JR NZ,	DSKERR		; Error if can't
	LD HL,	DEFBUF		; Use buffer at 0080 for bootstrap
	LD C,	1		; Read sector 1 of track 0
	CALL	READ		; Read in the boot
	JR NZ,	DSKERR		; Error msg if not there
	POP	AF		; Discard return from ACMD call
	JP	DEFBUF		; Go to boot routine in buffer at 0080

; "B" command - Boot system from drive B

BCMD:	LD C,	1		; Select drive 1
	JR	ACMD1		; Same code as boot from drive A

; "R" command - Read a disk sector into default buffer at 0080,
; then dump the buffer onto screen.
; Three args are: Drive (0 or 1), Cylinder, Sector

RCMD:	CP	3  		; Three args supplied?
	SCF			; Error if not
	RET	NZ		; ..
	LD C,	L		; Yes, first is drive number
	CALL	SELECT		; Select the drive
	JR NZ,	DSKERR		; May fail
	LD HL,	ARG2		; Pick up cylinder number
	LD C,	(HL)		; ..
	CALL	SEEK		; And move head to it
	JR NZ,	DSKERR		; May fail
	LD HL,	ARG3		; Pick up sector number
	LD C,	(HL)		; ..
	LD HL,	DEFBUF		; And point at default buffer
	CALL	READ		; Read that sector
	SET B0,	A		; If error, say it was a read
	JR NZ,	DSKERR		; Possible error
	LD HL,	DEFBUF		; Now point at buffer to dump
	LD DE,	SECSIZ/16       ; This many rows
	CALL	HDUMP		; Dump onto screen
	JR	DSKRPT		; Report where it was on disk

;Disk error reporter

DSKERR:	PUSH	AF		; Save error bits
	CALL	PSOUT		; Report the error
	DB	'disk error ',CH.EOT
	POP	AF		; Get error bits back
	CALL	HOUTSP		; Report the bits
DSKRPT:	LD A,	'U'             ; U for Unit
	CALL	CHOUT
	LD A,	(FDDRV)		; Get the selected unit number
	CALL	HOUTSP		; Report it
	LD A,	'T'		; T for Track
	CALL	CHOUT
	LD A,	(FDCYL)
	CALL	HOUTSP
	LD A,	'S'             ; S for Sector
	CALL	CHOUT
	LD A,	(FDSEC)
	CALL	HOUTSP
	OR      A               ; Clear CY, no command error
	RET

; Routine to dump a region of memory in HEX and ASCII on the screen.
; Args are: HL/ RAM addr to dump
;           DE/ Number of rows of 16 bytes to dump

HDUMP:	PUSH	HL		; Save starting address
	CALL	HWDOUT		; Type memory address
	CALL	SPACE		; A second space after address
	LD B,	16              ; Sixteen bytes per line
HDUMP1:	LD A,	(HL)		; Pick up byte to display
	INC	HL		; Pass it
	CALL	HOUTSP		; Dump it
	DJNZ	HDUMP1		; Loop over 16 bytes
	POP	HL		; Back to start of 16 bytes
	LD B,   16              ; Again, 16 bytes, now in ASCII
HDUMP2:	LD A,	(HL)		; Pick up a byte
	INC	HL		; Pass it
	RES B7,	A		; Only 7 bits of ASCII
	CP	20H		; Filter out controls and DELs
	JR C,	HDUMP3		; And print them as "dot"
	CP	07FH
	JR C,	HDUMP4
HDUMP3:	LD A,	'.'
HDUMP4:	CALL	CHOUT           ; Print char or dot
	DJNZ	HDUMP2		; Loop over 16 bytes again
	CALL	CRLFSP		; Type end of line
	RET	NZ		; Quit if anything typed in
	DEC	DE		; Count a line done
	LD A,	D		; Check for all lines done
	OR	E		; ..
	JR NZ,	HDUMP		; Loop if more to go
	RET

; "I" command - Input a byte from an I/O port and display it.
; If CR typed, do another one from next port. If "-" typed,
; do another one from previous port.
; One arg required, the port number (hex).

ICMD:	DEC	A		; Check for one arg
	SCF			; Fail if not
	RET	NZ		; ..
	LD C,	L		; Hold the port number in C
ICMD1:	CALL	CRLFSP		; Type answer on a new line
	LD A,	C		; Show the port number
	CALL	HOUTSP		; ..
	IN A,	(C)		; Get the data
	CALL	HOUTSP		; Show data
	CALL	TYIUC		; See if CR or "-" typed
	CP	CH.CR		; CR?
	JR Z,	ICMD2		; Go to next port if so
	CP	'-'		; Minus?
	JR Z,	ICMD3		; Previous port if so
	OR	A		; No command error, return to PROMPT
	RET

ICMD2:	INC	C		; Step to next port
	INC	C
ICMD3:	DEC	C               ; Back to previous port
	JR	ICMD1		; Go do that port

; "O" command of two args. Output second arg to port in first arg.

OCMD:	CP	2               ; Must have two args
	SCF			; Fail if not
	RET	NZ		; ..
	LD C,	L		; Port from first arg
	OUT (C),E		; Send data from second arg
	OR	A		; No error from command
	RET			; That was easy

; Primary String INput routine - collect a line from terminal.

PSIN:	LD B,	C		; Room for this many characters
PSINL:	CALL	TYIUC		; Get and raise a char
	CP	CH.CR		; Keep on until CR
	JR Z,	PSINCR		; Quit at end of line
	CP	CH.BS           ; Handle backspace
	JR Z,	PSINBS		; ..
	CP	CH.CTL		; Any other control char gives error
	RET	C		; ..
	LD (HL),A		; Else save it in buffer
	INC	HL		; Step buffer pointer
	DEC	C		; Count space in buffer
	JR NZ,	PSINL		; Loop if more room
	SCF			; Error, exceeded buffer
	RET			; Return with error

PSINCR:	LD (HL),A		; Store the CH.CR at end of string
	RET			; Return success

PSINBS:	DEC	HL		; Back up character pointer
	CALL	PSOUT		; Erase the deleted char
	DB	' '		; with BS SP BS (First BS was echoed)
	DB	CH.BS		; ..
	DB	CH.EOT
	INC	C		; One more space left
	LD A,	B		; Rubbed out too far?
	SUB	C		; ..
	JR NC,	PSINL		; No, OK
	RET			; Yes, fail return (should be allowed...)

; Character lookup and dispatch routine. Look for character, then get
; corresponding handler from following address table.

CDISP:	CPIR			; Search for the character
	RET	NZ		; Return if not found
	ADD HL,	BC		; Step to handler for it
	ADD HL,	BC		; ..
	ADD HL,	BC		; ..
	LD C,	(HL)		; Pick up handler address into BC
	INC	HL		; ..
	LD B,	(HL)		; ..
	RET			; Return answer in BC, Z flag says OK

; Routine to parse hex args after command letter on command line

CMARGS:	LD BC,	ZERO		; Offset into arg table, start at 0
	LD A,	(IY+0)          ; First char may be a car ret
	CP	CH.CR           ; ..
	JR NZ,	CMARG2		; If not, go parse args
	XOR	A		; Yes, zero args seen.
	RET			; Return that zero

CMARG1:	INC	C		; Seen another arg
	INC	C		; ..
	BIT B3,	C		; Too many?
	SCF			; Fail if so
	RET	NZ		; ..
CMARG2:	PUSH	BC		; Hold arg table offset
	CALL	HEXIN		; Get another arg
	POP	BC		; Recover table offset
	RET	C		; Quit if HEXIN failed
	LD IX,	ARG1		; Point at arg result slot
	ADD IX,	BC		; ..
	LD (IX+0),L  		; Put this arg in table
	LD (IX+1),H    		; ..
	CP	CH.SPC          ; Space after arg?
	JR Z,	CMARG1		; Yes, get another arg
	CP	','		; Comma?
	JR Z,	CMARG1		; Yes, get another arg
	CP	CH.CR           ; Should be Car Ret, then
	SCF			; Fail if not
	RET	NZ		; ..
	LD A,	C		; Get count of args parsed
	SRL	A		; Half of table offset
	INC	A		; Plus one
	RET			; Return count in A

; Hex value input routine

HEXIN:	LD HL,	ZERO		; Initialize number accumulator
	JR	HEXIN3		; Jump into loop

HEXIN1:	LD B,	4               ; Shift left one nibble
HEXIN2:	ADD HL,	HL		; ..
	RET	C		; Quit if more than 16 bits
	DJNZ	HEXIN2		; ..
	LD E,	A		; Add in new digit
	LD D,	0
	ADD HL,	DE		; ..
	RET	C		; Fail if carries out (can't)
HEXIN3:	LD A,	(IY+0)          ; Pick up another character from string
	INC	IY		; Step thru string
	LD C,	A		; Crunch it to hex
	CALL	ASCHEX		; ..
	JR NC,	HEXIN1		; Go if was a hex digit
	LD A,	C		; Not a hex digit. Return the break char in A
	OR	A		; No error flag in CY
	RET

;Collapse '0'-'9' and 'A'-'F' into 4 bits. Else return CY.

ASCHEX:	SUB	'0'		; Range check. Below digits?
	RET	C		; Fail if so
	CP	'9'-'0'+1       ; Bigger than '9'?
	CCF			; If 0-9, no carry
	RET	NC		; Return the 0-9 as binary
	SUB	'A'-'9'-1       ; Crunch out space between 9 and A
	CP	10              ; Should be 10 or more
	RET	C		; Middle characters are bad
	CP	16              ; Better not be more than 15
	CCF			; CY if so
	RET			; Return 0-15 or CY

; Output 16-bit hex value from HL, follow with a space.
; Also, output 8-bit hex value from A, followed by space.

HWDOUT:	LD A,	H		; High byte of 16
	CALL	HEXOUT		; Output 2 hex chars
	LD A,	L		; Low byte of 16
HOUTSP:	CALL	HEXOUT		; Output 2 hex chars
	CALL	SPACE		; Output a space
	RET

; Output 8-bit hex value as hex

HEXOUT:	PUSH	AF		; Hold input value
	RRA			; Get left 4 bits
	RRA
	RRA
	RRA
	CALL	NIBOUT		; Output one hex char
	POP	AF		; Get back right 4 bits
NIBOUT:	AND	0FH		; Mask to 4 bits
	ADD A,	90H		; Magic conversion to 0-9, A-F
	DAA
	ADC A,	40H
	DAA
	CALL	CHOUT           ; Output the character
	RET

; Output a text string, in line after caller. Terminated by CH.EOT

PSOUT:	EX (SP),HL		; Adjust args for easier end test
	CALL	PSOUTL		; Output the string
	EX (SP),HL		; Fix stack again
	RET

PSOUTL:	LD A,	(HL)		; Pick up char from string
	INC	HL		; Step past it
	CP	CH.EOT          ; Terminator?
	RET	Z               ; Done if so
	CALL	CHOUT		; Output the text
	JR	PSOUTL		; Loop til CH.EOT

; Output EOL and space

CRLFSP:	CALL	PSOUT		; String output, inline here
	DB	CH.CR, CH.LF, CH.EOT
SPACE:	LD A,	CH.SPC
	CALL	CHOUT		; Output a space
	RET

; Input a character, then raise any lower case.

TYIUC:	CALL	VCONIN		; Call low level console input routine
	PUSH	AF		; Hold the char
	CALL	VCRTOU		; Echo it to screen
	POP	AF		; Recover it
	CP	'Z'+1		; Lower case?
	RET	C		; No, return it as is
	SUB	'a'-'A'         ; Yes, raise it
	RET

; Command handlers character output routine. Checks for abort due to
; user typing in during the output.

CHOUT:	CALL	VCRTOU		; Do the character output
	CALL	VCONST		; Anything typed?
	JR Z,	CHOUT2		; Go if not
	CALL	VCONIN		; Yes, get the char
	CP	CH.CR		; Was it a char ret?
	JR Z,	CHOUT1		; Yes
	CALL	VCONIN		; No, pause until something else typed
	JR	CHOUT2		; Then go on

CHOUT1:	LD (PAUSCH),A           ; Remember char typed in during typeout
CHOUT2:	LD A,	(PAUSCH)        ; Anything typed in?
	OR	A               ; Return non-Z if so
	RET

; See if anything has been typed in.

CONST:
        IN A, (SIO.CS)           ; character on Console SIO?
        AND 1
        JZ CONST1               ; NO - just check ring buffer

        IN A, (SIO.CD)
        PUSH HL                 ; CONST doesn't seem OK to clobber registers
        PUSH BC
        CALL KBINT1             ; YES - place on ring buffer
        POP BC
        POP HL

CONST1:
        LD A,	(TYICT)		; Anything in ring buffer?
	OR	A		; ..
	RET	Z		; Return Z if not
	LD A,	FF		; Yes, return non-Z and A/ FF
	RET

; Return character from keyboard. Wait if needed.

CONIN:	CALL	CONST		; Anything there yet?
	JR Z,	CONIN		; Wait if not
	PUSH	HL		; Yes, save HL pair
	CALL	TYI1		; Get the char
	POP	HL		; Restore regs
	RET			; Return char in A

	XOR	20H		; F37B EE 20 Extraneous?

KBINT1:	LD C,	A		; Char to add to ring
	LD HL,	TYICT		; Ring fullness count
	LD A,	(HL)		; Pick up count
	INC	A		; Add one more character
	CP	NRING		; Ring full?
	RET	NC		; Don't add another char, if full
	LD (HL),A		; OK, add this one
	LD HL,	KBPUTR		; Point at ring putter
	CALL	TYI2		; Compute address and wrap
	LD (HL),C		; Put char in ring
	RET			; Go dismiss interrupt

TYI1:	LD HL,	TYICT		; One less char in ring
	DEC	(HL)		; ..
	LD HL,	KBTAKR		; Point at ring taker
TYI2:	LD A,	(HL)		; Pick up putter or taker low bits
	INC	A		; Step the pointer
	AND	NRING-1		; Wrap within ring
	LD (HL),A		; Update pointer
	LD HL,	KBRING		; Now find the char it points to
	ADD A,	L		; ..
	LD L,	A		; ..
	LD A,	(HL)		; Pick up the character, for taker case
	RET

MTRTIM:	LD HL,	FDRUNT		; Count down run time of floppy motor
	DEC	(HL)		; ..
	RET	NZ		; Return unless went to zero
	IN A,	(PIO.SD)	; In which case, deselect the drive
	AND	0F8H
	OUT (PIO.SD),A
	RET

KBDINT:	LD (SAVESP),SP		; Keyboard interrupt vectors here
	LD SP,	INTSTK		; Set up interrupt stack
	PUSH	HL		; Save registers
	PUSH	DE		; (Can't use alt's, user prog may
	PUSH	BC		;  be using them.)
	PUSH	AF
	IN A,	(PIO.KD)        ; Get the keyboard data
	CPL			; Fix data inversion
	AND	7FH		; Just 7 bits of ASCII
	CALL	KBINT1		; Put char in ring buffer
	POP	AF		; Restore registers
	POP	BC
	POP	DE
	POP	HL
	LD SP,	(SAVESP)        ; Restore user's stack pointer
	EI			; Done interrupt
	RETI

CTCINT:	LD (SAVESP),SP		; CTC chan 3 comes here once a second
	LD SP,	INTSTK		; PI stack pointer
	PUSH	HL		; Save user's regs
	PUSH	DE
	PUSH	BC
	PUSH	AF
	CALL	MTRTIM          ; Time out the disk motor
	POP	AF              ; Restore regs, that's all
	POP	BC
	POP	DE
	POP	HL
	LD SP,	(SAVESP)
	EI
	RETI

CLKINT:	LD (SAVESP),SP		; Channel 1 of CTC comes here
	LD SP,	INTSTK		; We just count down a cell for user
	PUSH	HL
	PUSH	AF
	LD HL,	(TODCLK)
	DEC	HL
	LD (TODCLK),HL
	POP	AF              ; Restore regs and dismiss
	POP	HL
	LD SP,	(SAVESP)
	EI
	RETI

SIOST:	IN A,	(SIO.BS)        ; Check status of SIO B's input
	AND	1               ; Anything there?
	RET	Z               ; Return if not
	LD A,	FF              ; Yes, return all ones
	RET

SIOIN:	CALL	SIOST		; Get a char from SIO B's input
	JR Z,	SIOIN		; Wait till something to get
	IN A,	(SIO.BD)        ; Read the char
	AND	7FH		; Get the char
	RET

SIOOUT:	PUSH	AF		; Send char to SIO B
SIOBW1:	IN A,	(SIO.BS)        ; TX buffer empty?
	AND	4               ; ..
	JR Z,	SIOBW1          ; Wait for it
SIOBW2:	IN A,	(SIO.BS)        ; Clear to send?
	AND	8               ; For printer flow control
	JR Z,	SIOBW2          ; Wait for that, too
	POP	AF              ; Recover the character
	OUT (SIO.BD),A          ; Send it out
	RET

; Here is the CRT output routine. The 820 has an 24 by 80 CRT controller
; on the board, with the refresh RAM stashed in shadow memory at
; location 3000H. This code updates that RAM and handles some control
; sequences.

; Perhaps this code shouldn't all live in RAM, but should run in ROM,
; since you have to switch to shadow anyhow to get at the CRT RAM.
; That would make the BIOS smaller...

; Anyhow, here it is. Enter at CRTOUT with the character in register A.

CRTOUT:	PUSH	HL              ; Save user's registers
	PUSH	DE
	PUSH	BC
	LD C,	A               ; Copy the character for a while

SIOCW1:
        IN A, (SIO.CS)          ; Wait for TX buffer space
        AND 4
        JR Z, SIOCW1

        LD A, C                 ; Send it
        OUT (SIO.CD),A

	DI                      ; Turn off interrupts, since we are
				; about to map out low memory
	LD (SAVESP),SP		; And that lets us borrow the 
	LD SP,	INTSTK		;  interrupt level stack for this code
	IN A,	(PIO.SD)        ; Switch locs 0000-3FFF to shadow
	SET B7,	A               ; By twiddling this bit
	OUT (PIO.SD),A
	LD HL,	CRSCHR		; Character under the cursor
	LD B,	(HL)		; ..
	LD HL,	(CURSOR)	; Point where cursor is
	LD A,	H		; Make sure cursor is within screen RAM
	AND	0FH		; ..
	OR	CRTPAG		; ..
	LD H,	A		; ..
	LD (HL),B		; Put back char under cursor
	CALL	CRTWRK		; Main body of CRTOUT
	LD A,	(HL)		; Get char where cursor is
	LD (CRSCHR),A           ; Hold copy of char under cursor
	CP	CH.SPC		; Is it a space?
	SET B7,	A		; Make it inverse video
	JR NZ,	CRTOU1		; If not space, just invert it
	LD A,	(SPCCRS)        ; Special char if cursor is on space
CRTOU1:	LD (HL),A		; Make cursor visible
	LD (CURSOR),HL		; Remember where cursor wound up
	LD SP,	(SAVESP)        ; Back to caller's stack
	IN A,	(PIO.SD)        ; Put CRT RAM back in shadow
	RES B7,	A		; ..
	OUT (PIO.SD),A          ; ..
	EI                      ; Allow interrupts now
	POP	BC              ; Restore registers
	POP	DE
	POP	HL
	RET                     ; Return from CRTOUT

CRTWRK:	LD DE,	SEQFLG          ; In the middle of a multi char sequence?
	LD A,	(DE)		; ..
	OR	A		; ..
	JP NZ,	CRTSEQ          ; Go handle the sequence
	LD A,	C		; Character to "type" on screen
	CP	CH.CTL          ; Control character?
	JR C,	CRTCTL		; Yes, go dispatch on it
CRTSTO:	LD (HL),C		; Put char in screen RAM
	INC	HL		; Use a column
	LD A,	L		; Check for right edge
	AND	7FH		; ..
	CP	80              ; Edge of screen?
	RET	C		; No
	CALL	CRTCR		; Yes, wrap the cursor
	CALL	CRTLF		; By doing a CR LF
	RET

CRTCTL:	PUSH	HL		; Here to dispatch to control char handler
	LD HL,	CRTCTB		; Point at list of known chars
	LD BC,	NCRTCC		; Number of them
	CALL	CDISP		; Look up the handler
	POP	HL		; Restore cursor
	RET	NZ		; If not found, ignore ctl char
	PUSH	BC		; Call that routine
	RET			; Go to it.

CRTCTB: DB      01FH,01EH,01BH,01AH     ; Control chars we handle
	DB      018H,011H,00DH,00CH
	DB      00BH,00AH,009H,008H
	DB      007H
NCRTCC  EQU     $-CRTCTB

	DW	CRTBEL		; And their handler routines
	DW	CRTBS
	DW	CRTHT
	DW	CRTLF
	DW	CRTVT
	DW	CRTFF
	DW	CRTCR
	DW	CRTXON
	DW	CRTCAN
	DW	CRTSUB
	DW	CRTESC
	DW	CRTRS
	DW	CRTUS

; ESCAPE char. Followed by an "=" and row and column (32 offset)

CRTESC:	LD A,	1  		; Set a one into SEQFLG
	LD (DE),A		; and get the args later
	RET

; US (01FH) says to display the next control char, not interpret it.

CRTUS:	LD A,	4               ; Set marker to show next ctl char
	LD (DE),A		;  in SEQFLG
	RET

; Backspace - cursor left unless at margin

CRTBS:	LD A,	L		; Lines are 128 aligned
	AND	7FH		; Are we at left margin?
	RET	Z		; If so, return
	DEC	HL		; Else back up one
	RET			; Done backspace

; Formfeed says cursor right. (Wonderful choice)

CRTFF:	LD A,	L		; What column are we in now?
	AND	7FH		; ..
	CP	79              ; At the edge?
	RET	NC		; If so, don't do nothin
	INC	HL		; OK, move right.
	RET

; Horiz tab. Move to next 8-col tab stop.

CRTHT:	LD DE,	8
	LD A,	L               ; Stop which is at or to left of cursor
	AND	78H
	ADD A,	E               ; Now the next one to the right
	CP	80              ; Beyond right edge?
	RET	NC              ; If so, ignore the tab
	LD A,	L		; OK to do the tab
	AND	0F8H		; Previous tabstop
	LD L,	A		; ..
	ADD HL,	DE		; Plus eight
	RET

; Bell - flaps a hardware bit in case you want to build a bell

CRTBEL:	IN A,	(PIO.SD)        ; Preserve rest of the bits
	SET B5,	A               ; Flap bit 5
	OUT (PIO.SD),A
	RES B5,	A               ; And un-flap it
	OUT (PIO.SD),A
	RET

; Carriage return. Back cursor up to start of current row.

CRTCR:	LD A,	L		; Get current row
	AND	80H		; Mask it off to 0
	LD L,	A		; Update it
	RET			; That was easy

; Control Z (SUB) says clear screen and re-init scope handler

CRTSUB:	LD HL,	CRTRAM          ; Cursor to top of screen
	PUSH	HL		; Hold while we clear it
	LD DE,	CRTRAM+1        ; The old BLT .+1 trick
	LD BC,	0C00H		; Whole screen
	LD (HL),CH.SPC          ; Clear with spaces
	LDIR                    ; Zap!
	POP	HL		; Restore cursor
	LD A,	23              ; Reset the scroll hardware
	LD (SCROLL),A		; and our copy of it
	OUT (CRT.SC),A
	RET                     ; That's it, screen cleared.

; Control X (CAN, 018H) says clear to end of line

CRTCAN:	PUSH	HL		; Hold cursor
	LD A,	L		; Get column
	AND	7FH		; ..
	LD C,	A		; Hold current column
	LD A,	80              ; Clear up to col 80
	SUB	C		; How many to do?
	LD B,	A		; Loop counter
	CALL	CRTBLK          ; Blank a group of chars
	POP	HL		; Restore cursor
	RET

; Control Q (XON, 11H) says clear to end of screen (another wonderful choice)

CRTXON:	CALL	CRTCAN		; First clear to end of current line
	PUSH	HL		; Hold the cursor
	LD A,	(SCROLL)	; Get scroll offset
	LD C,	A		; ..
CRTXN1:	LD A,	L		; Figure out row number from HL
	RLA
	LD A,	H
	RLA
	AND	1FH
	CP	C		; At end of screen?
	JR Z,	CRTXN2          ; Go if so
	CALL	NXTLIN          ; No, find next line
	CALL	CLRLIN		;  and clear it
	JR	CRTXN1		; See if done now

CRTXN2:	POP	HL		; Restore original cursor
	RET

; VT (Ctrl K) says cursor up

CRTVT:	LD DE,	-80H            ; Back up cursor by one row
	ADD HL,	DE		; ..
	LD A,	H		; Make sure still in CRT RAM
	CP	CRTPAG
	RET	NC              ; Quit if not
	LD H,	CRTPAG+11       ; No, wrap back to top
	RET

; Compute address of next line

NXTLIN:	LD DE,	80H             ; Step one line
	ADD HL,	DE
	LD A,	H		; Off the end?
	CP	CRTPAG+12
	RET	C               ; OK if not
	LD H,	CRTPAG          ; Yes, back up to base
	RET

; Linefeed. Cursor down and maybe scroll up.

CRTLF:	LD A,	L               ; Figure present line number
	RLA			;  from HL
	LD A,	H
	RLA
	AND	1FH
	LD C,	A		; Hold it
	CALL	NXTLIN          ; Step to next line
	LD A,	(SCROLL)        ; Are we at bottom of screen?
	CP	C		; ..
	RET	NZ		; If not, no need to scroll
	PUSH	HL		; Have to scroll. Hold cursor
	CALL	CLRLIN		; Put up a row of spaces
	ADD HL,	HL		; Shift row into H register
	LD A,	H
	AND	1FH             ; Here's row number
	LD (SCROLL),A           ; Let hardware rotate screen for us
	OUT (CRT.SC),A          ; ..
	POP	HL              ; Recover cursor
	RET

CLRLIN:	LD A,	L               ; Go to beginning of this line
	AND	80H
	LD L,	A               ; ..
	LD B,	80              ; Clear 80 columns
CRTBLK:	LD (HL),CH.SPC          ; Clear with spaces
	INC	HL		; Step thru CRT RAM
	DJNZ	CRTBLK          ; Fill whole line
	RET

; RS (01EH) says home cursor

CRTRS:	LD C,	CH.SPC          ; Go to row 0 (plus 32)
	JR	CRTRS1		; Using part of ESCAPE handler

; Multi character sequences

CRTSEQ:	EX DE,	HL		; Clear sequence flag for next time
	LD (HL),0
	EX DE,	HL
	CP	1               ; Escape sequence?
	JR NZ,	CRTSQ1          ; No, try US sequence
	LD A,	C               ; Yes, what's the next char?
	CP	'='             ; Should be equals
	RET	NZ              ; If not, junk it.
	LD A,	2               ; Say row is next
	LD (DE),A		;  in SEQFLG
	RET

CRTSQ1:	CP	2               ; Waiting for row?
	JR NZ,	CRTSQ2		; Go if not
	LD A,	3               ; Yes, say now want column
	LD (DE),A		;  in SEQFLG
CRTRS1:	LD A,	(SCROLL)        ; Compute in the autoscroller
	ADD A,	C		; plus desired row
	SUB	CH.SPC-1	; Remove 32 bias
CRTWL:	SUB	24		; Wrap as needed
	JR NC,	CRTWL           ; ..
	ADD A,	24              ; ..
	OR	CRTPAG+CRTPAG   ; Figure CRT RAM addr for this row
	LD H,	A
	LD L,	0
	SRL	H
	RR	L
	RET

CRTSQ2:	CP	3               ; Waiting for column?
	JR NZ,	CRTSQ3          ; No
	LD A,	C		; Yes, get the column
	SUB	CH.SPC		; Remove the bias
CRTWC:	SUB	80		; Wrap the column
	JR NC,	CRTWC           ; ..
	ADD A,	80
	OR	L               ; In current line
	LD L,	A
	RET

CRTSQ3:	CALL	CRTSTO		; Just store the char. We fouled up.
	RET

; Here are the floppy disk handling routines. These will handle either
; five or eight inch floppies using a WD1771 controller chip.


; SELECT prepares to use the drive supplied in register C
; 0 = A, 1 = B, 2 = C (= A + Side), 3 = D (= B + Side)

SELECT:	INC	C		; Make arg 0-3 be 1-4
	LD A,	C		; Check it
	CP	5		; Was it 4 or more?
	RET	NC		; Return if so, no good.
	CP	3		; Was it 2 or 3?
	JR C,	SELEC1		; Go if not
	INC	C		; Yes, make 2 and 3 into 5 and 6
	INC	C		; Thus setting Side bit in B2, drives in B0-1
SELEC1:	CALL	POKEFD		; Poke the timer, get sys PIO
	LD B,	A		; Hold copy of sys bits
	AND	0F8H		; Flush old drive and side bits
	OR	C		; Put in new ones
	CALL	DSKUP1		; Go set them in controller, wait for drive
	JR NZ,	SELEC2		; Go if drive came up OK
	LD A,	B		; Drive not happy. Restore system bits
	OUT (PIO.SD),A          ; As before this selection
	LD A,	80H             ; Return error indication
	OR	A		; Clear Z flag
	RET                     ; Fail return from SELECT

SELEC2:	LD HL,	FDDRV           ; OK, point at selected drive slot
	LD A,	(HL)		; Get old drive
	LD (HL),C		; Set new drive
	CP	FF              ; Was there no old one?
	JR Z,	SELEC3		; If so, no need to remember cylinder
	INC	HL		; Point at cylinder slot
	ADD A,	L               ;  for the old drive
	LD L,	A		;  ..
	IN A,	(FDC.CY)        ; Read old cylinder number
	LD (HL),A		; Put it in vector for next use of drive
SELEC3:	LD HL,	CYLVEC		; Now get cylinder of new drive
	LD A,	L
	ADD A,	C
	LD L,	A
	LD A,	(HL)		; ..
	CP	FF		; If unknown, home this drive
	JR Z,	HOME            ; ..
	OUT (FDC.CY),A          ; Else tell 1771 where the head is
	XOR	A		; Return Z, success
	RET

; HOME restores the drive to track zero.

HOME:	CALL	DISKUP		; Get the drive up to speed first
	RET	Z		; Return if can't
	XOR	A		; OK, set cylinder to zero
	LD (FDCYL),A		; ..
HOME1:	LD B,	0CH		; Set seek track 0 command
	CALL	FDCSEK		; Go do it
	XOR	04H		; Set up error bits for return
	AND	9CH		; ..
	RET

; SEEK seeks to the requested cylinder, arg in register C

SEEK:	CALL	DISKUP		; Make sure disk is spinning
	RET	Z		; It isn't. Fail.
	LD B,	77              ; Tracks on an 8 incher
	IN A,	(PIO.SD)        ; Is it 8 or 5?
	BIT B4,	A		; ..
	JR NZ,	SEEK1		; Go for 8
	LD B,	40              ; Five incher has 40 tracks
SEEK1:	LD A,	C		; Desired track
	CP	B		; In range?
	RET	NC		; Fail if not.
	LD (FDCYL),A		; OK, remember the target cylinder
	OUT (FDC.DA),A          ; Tell the 1771 where to go
	LD B,	1CH		; Seek op
	CALL	FDCSEK		; Plug in step rate and do it
	AND	98H		; Check for any errors
	RET	Z		; Done if OK
	CALL	HOME1		; Seek failed. Try recalibrating
	RET	NZ		; That failed too?
	LD A,	C		; Try the seek again if recal worked
	OUT (FDC.DA),A
	LD B,	1CH
	CALL	FDCSEK
	AND	98H             ; Return success or fail this time
	RET

; Sector Read and Write routines

WRITE:	CALL	DISKUP		; Get the drive up to speed
	RET	Z		; Quit if can't
	CALL	FDCSTS		; See if disk is write locked
	BIT B6,	A		; ..
	RET	NZ		; Don't try writing if locked
	LD B,	0A8H            ; Write opcode
	JR	READ1           ; Much like read from here on

READ:	CALL	DISKUP		; Get the drive up to speed
	RET	Z		; Quit if can't
	LD B,	88H		; Read opcode
READ1:	LD (FDDMA),HL		; HL says where to read/write from
	LD HL,	FDSEC		; Store sector within cylinder
	LD (HL),C		; ..
	INC	HL		; Save the opcode in FDOP
	LD (HL),B		; ..
	INC	HL		; Point at RETRYC
	LD (HL),11		; Set initial retry count
AGAIN1:	DI			; Turn off interrupts during transfer
	LD HL,	NMIVEC		; Use NMI mechanism for the data xfer
	LD D,	(HL)		; Hold old contents of 0066H
	LD (HL),0C9H		; Put a "ret" there for now
	LD HL,	FDSSIZ		; Number of bytes in a sector
	LD B,	(HL)		; Set for INIR/OTIR
	LD C,	FDC.DA		; I/O port for read and write data
	LD HL,	(FDDMA)		; Memory address for the sector
	LD A,	(FDSEC)		; Tell it what sector we want
	OUT (FDC.SE),A		; ..
	CALL	FDCSTS		; Stop old op, get status
	BIT B5,	A		; Head loaded yet?
	LD A,	(FDOP)		; Pick up the read or write
	JR NZ,	NOLOAD		; Go if no need to load it
	OR	4               ; Tell it to load head
NOLOAD:	CALL	FDCDO		; Do the read or write
	BIT B5,	A		; Is this a read or a write?
	JR NZ,	WRWAIT		; Go handle write
RDWAIT:	HALT			; Wait for NMI
	INI			; Read a byte
	JP NZ,	RDWAIT		; Loop if not done sector
	CALL	FDCSKW		; Wait for it to finish CRC
	AND	9CH		; Error bits for read
	JR	RWWAT1		; Go clean up at end

WRWAIT:	HALT			; Wait for NMI, write case
	OUTI			; Output a byte
	JP NZ,	WRWAIT		; Loop till whole sector done
	CALL	FDCSKW		; Wait for CRC to go out, get status
	AND	0BCH		; Error bits for write case.
RWWAT1:	LD HL,	NMIVEC		; Restore the contents of 0066H
	LD (HL),D		; ..
	EI			; Allow interrupts again
	RET	Z		; Return if no errors
	LD HL,	RETRYC		; Nuts, there were errors.
	DEC	(HL)		; Count the retries
	JR NZ,	AGAIN		; If some left, try it all again
	OR	A		; Else set NZ with error bits
	RET			;  and fail the read/write.

AGAIN:	LD HL,	FDCYL		; Do another seek to the rd/wr cylinder
	LD C,	(HL)		; ..
	CALL	SEEK		; ..
	JR	AGAIN1		; And re-do the read or write.

FDCSEK:	LD A,	(FDSTEP)        ; Pick up step rate bits
	AND	3
	OR	B		; Put in seek/home operation
	CALL	FDCDO		; Hand it to the chip
FDCSKW:	IN A,	(FDC.CS)	; Wait for it to finish
	BIT B0,	A		; ..
	JR NZ,	FDCSKW		; ..
	RET

FDCDO:	OUT (FDC.CS),A		; Do the requested op in 1771
	CALL	FDCDOW		; And wait a little while
FDCDOW:	EX (SP),HL		;  since 1771 is a bit slow on 
	EX (SP),HL		;  getting the status right
	RET

FDCSTS:	LD A,	0D0H		; Reset current op
	CALL	FDCDO		; Do that and delay
	IN A,	(FDC.CS)	; See what status is
	RET

POKEFD:	LD A,	WHIRTM		; Restart motor timer at max
	LD (FDRUNT),A
	CALL	POKEF1          ; A little delay
	IN A,	(PIO.SD)        ; Get system PIO for drive bits
POKEF1:	RET

DISKUP:	CALL	POKEFD		; Restart timer, get drive bits
	AND	7
	RET	NZ              ; Return if one is selected
	IN A,	(PIO.SD)        ; None selected. Get other bits
	PUSH	HL		; Save register
	LD HL,	FDDRV		; Get desired drive
	OR	(HL)		; Mix with other PIO.SD bits
	POP	HL		; Restore register
DSKUP1:	PUSH	HL		; Save two reg pairs
	PUSH	BC
	OUT (PIO.SD),A          ; Set new drive bits
	LD A,	87H		; Tell CTC 1 to time us
	OUT (CTC.C1),A
	LD A,	9CH             ;  for a while
	OUT (CTC.C1),A
	LD HL,	07D0H		; This many ticks says disk doesn't turn
	LD (TODCLK),HL
	CALL	FDCSTS          ; See if index bit is on
	AND	2
	LD B,	A
	CALL	IDXWAT          ; Wait for index bit to change
	JR C,	OFFLIN		; If it didn't, give up on drive
DSKUP2:	LD HL,	(TODCLK)        ; It changed. Now wait for up to speed
	CALL	IDXWAT		; ..
	JR C,	OFFLIN		; Go if failed
	CALL	IDXWAT		; Wait for two half square-waves
	JR C,	OFFLIN		; Go if failed
	LD DE,	(TODCLK)        ; Now see if it's fast enough
	SBC HL, DE
	LD (IDXTIM),HL          ; Save rotation time
	LD DE,	0D2H            ; Fast enough?
	OR	A		; Clear CY for SBC
	SBC HL, DE		; Is it this fast yet?
	JR NC,	DSKUP2		; If not, let it turn some more
	LD E,	80H		; Fast enough.Success code. Go accept it
	JR	OFLIN1		; ..

OFFLIN:	IN A,	(PIO.SD)        ; Disconnect from this drive. It's bad
	AND	0F8H
	OUT (PIO.SD),A
	LD E,	0               ; Failure code
OFLIN1:	LD A,	3  		; Through with this CTC channel
	DI			; Because of CTC chip bug
	OUT (CTC.C1),A
	EI			; ..
	POP	BC		; Restore registers
	POP	HL		; ..
	LD A,	E		; Success/fail code
	OR	A		; Non-Z says OK
	RET

IDXWAT:	CALL	FDCSTS          ; Get Index hole bit
	AND	2               ; ..
	XOR	B		; Compare to old bit
	JR NZ,	IDXCHG		; Go when it changes
	LD A,	(TODCLK+1)	; See if time to give up
	BIT B7,	A		; ..
	JR Z,	IDXWAT		; No, keep waiting
	SCF			; Failed. This thing isn't turning
	RET

IDXCHG:	LD A,	B               ; Aha. It changed.
	XOR	2		; Remember the new Index value
	LD B,	A		; ..
	RET                     ; Return from IDXWAT
        .DEPHASE

	ASEG
        IFDEF AS_COM
	ORG	0900H
        ELSE
	ORG	0800H
        ENDIF

        .PHASE	0F7F0H		; Runs here, lives at byte 0 of the
				;  second EPROM, at 0800H in shadow

; First is a vector into the routines in this EPROM, so they can be
; developed separately.

DCMD:	JP	DCMD1
CCMD:	JP	CCMD1
MCMD:	JP	MCMD1
FCMD:	JP	FCMD1
XCMD:	JP	XCMD1
GCMD:	JP	GCMD1
VCMD:	JP	VCMD1
TCMD:	JP	TCMD1

; "D" command - dumps an area of memory

DCMD1:	DEC	A		; How many args?
	JR Z,	DCMD2		; Go if one, HL says where
	DEC	A		; Maybe two
	JR Z,	DCMD3		; Go if two
	LD HL,	(PRVADR)	; No args. Dump from previous address
DCMD2:	LD DE,	256/16		; Default is 256 bytes
	JR	DCMD5		; Go dump them

DCMD3:	EX DE,	HL		; Dump from arg1 thru arg2
	SBC HL, DE		; Compute length
	LD B,	4               ; Divide by 16
DCMD4:	SRL	H
	RR	L
	DJNZ	DCMD4
	INC	HL              ; Round up
	EX DE,	HL		; Args to HDUMP are set
DCMD5:	CALL	VHDUMP		; Call dumper in other ROM
	LD (PRVADR),HL          ; Update previous addr for next "D" command
	RET

; "M" command - modify memory at loc ARG1

MCMD1:	CALL	TYPADR		; Show location to be modified
	CALL	VTYIUC		; What does user say?
	CP	CH.CR           ; No change?
	JR Z,	MCMD4		; Yup
	CP	'-'		; Back up?
	JR Z,	MCMD5		; Yup
	CP	','		; Comma?
	JR NZ,	MCMD2		; No, probably hex
	CALL	VTYIUC		; For Comma, take next char and store it
	JR	MCMD3		; Go store

MCMD2:	CALL	VASCHX		; See if it's a hex char
	CCF			; Return bad if not
	RET	NC		; ..
	RLCA			; Yes, shift to high nibble
	RLCA
	RLCA
	RLCA
	LD C,	A		; Hold for a moment
	CALL	VTYIUC		; Get second hex char
	CALL	VASCHX		; Check it
	CCF			; Fail if not hex
	RET	NC		; ..
	OR	C		; Mix with first 4 bits
MCMD3:	LD (HL),A		; Store in memory
	CALL	MERROR		; Make sure it took
MCMD4:	INC	HL		; Step to next mem loc
	INC	HL		; ..
MCMD5:	DEC	HL		; Back up for "-" command
	JR	MCMD1		; See what's next

; "G" command - do a CALL to stated address

GCMD1:	DEC	A		; Must be one arg
	SCF			; Else don't do it
	RET	NZ		; ..
	PUSH	HL		; Move the addr to IX (for some reason)
	POP	IX		; ..
	CALL	GCMDGO		; Go to that addr
	OR	A		; It returned, so back to PROMPT
	RET			; with success flag

GCMDGO:	JP	(IX)		; Call user routine

; Memory exercisor, "X" command. Tests memory and types a "+" on the
; CRT after each pass. Two args, the low and high limits of memory to test.

XCMD1:	CP	2               ; Need two args for range to test
	SCF			; Fail if not
	RET	NZ		; ..
	INC	DE		; OK, set DE = first untested byte
	LD E,	D		; Ending page number
	LD D,	H		; Starting page number
	LD B,	0               ; XOR in a different number each pass
XCML1:	LD H,	D               ; Highbyte of starting test addr
	LD L,	0               ; Actually start at byte 0 of that page
XCML2:	LD A,	L		; Test data = adr hi xor adr lo xor pass
	XOR	H		; ..
	XOR	B               ; XOR in the pass number
	LD (HL),A		; Put it in ram
	INC	HL		; Step thru RAM
	LD A,	H		; Up to ending page?
	CP	E		; ..
	JR NZ,	XCML2		; No, keep on filling
	LD H,	D		; Yes, back to start of pattern
	LD L,	0
XCML3:	LD A,	L               ; Compute the same XOR
	XOR	H
	XOR	B
	CALL	MERROR          ; Check and report it
	RET	NZ              ; Quit if user types anything
	INC	HL		; Step through memory
	LD A,	H		; Check for end
	CP	E		; ..
	JR NZ,	XCML3		; Loop over whole test region
	INC	B		; Pass number for XORing
	LD A,	'+'             ; Pass indicator
	CALL	VCHOUT          ; Type the plus
	JR Z,	XCML1           ; Unless banging on kbd, loop
	RET			; Quit. Someone typed.

MERROR:	CP	(HL)		; If modification worked,
	RET	Z		; Return OK
	PUSH	AF		; Else complain
	CALL	TYPADR          ; Show where it failed
	CALL	VPSOUT		; say it failed
	DB	'should=',CH.EOT
	POP	AF		; What it should be
	CALL	VHOUSP		; ..
	RET

TYPADR:	CALL	VCRLFS		; New line and space
	CALL	VHWDOU		; Output the address from HL
	LD A,	(HL)		; Pick up what's in memory
	CALL	VHOUSP		; Show that, space.
	RET

; "F" command - Fill memory with a value

FCMD1:	CP	3               ; Need three args
	SCF			; Fail if not
	RET	NZ		; ..
FCMD2:	LD (HL),C		; Fill a byte
	PUSH	HL		; Check for end
	OR	A
	SBC HL, DE
	POP	HL
	INC	HL		; On to next byte
	JR C,	FCMD2		; Loop unless done
	RET

; "C" command - Copy Fromfirst, Fromlast, Tofirst

CCMD1:	CP	3               ; Three args needed
	SCF			; ..
	RET	NZ		; Fail if not
	CALL	ARGADJ		; Fiddle the three args for loop
	LD A,	C		; Is length zero?
	OR	B		; ..
	RET	Z		; If so, don't move 64K
	LDIR			; OK, move it!
	RET

ARGADJ:	EX DE,	HL		; Adjust args for LDIR and CPIR
	OR	A		; Clear CY
	SBC HL, DE		; Get count from first/last
	EX DE,	HL		; DE = count, actually minus 1
	PUSH	DE		; Shuffle them around
	PUSH	BC		; ..
	POP	DE		; Here's destination
	POP	BC		; Here's count -1
	INC	BC		; Make it Count
	RET			; And HL has First source

; "V" command - verify one area against another. Args as in "C" command

VCMD1:	CP	3               ; Need three args
	SCF			; Fail if not
	RET	NZ		; ..
	CALL	ARGADJ		; Adjust args for compare loop
	JR	VCMD3		; End test first in case length zero

VCMD2:	LD A,	(DE)		; Pick up one region's byte
	CALL	MERROR		; Check and report if different
	RET	NZ		; Return if user types.
	INC	HL		; Step both pointers
	INC	DE		; ..
	DEC	BC		; and count
VCMD3:	LD A,	B		; End check
	OR	C		; Is count now zero?
	JR NZ,	VCMD2		; No, keep verifying
	RET

; "T" command - expensive typewriter, copies from keyboard to
; printer. An arg is the baud rate code for printer.

TCMD1:	LD A,	L		; Check for an argument
	AND	0FH		; ..
	JR NZ,	TCMD2		; Use it if any
	LD A,	7               ; If none, use 1200 baud
TCMD2:	OUT (BRG.B),A           ; Choose baud rate for SIO B
	LD A,	CH.SUB          ; Clear CRT screen
	CALL	VCRTOU		; ..
	CALL	VPSOUT		; Announce typewriter mode
	DB	'...820 TYPEWRITER  VER. 1.0...'
	DB      CH.CR,CH.LF
	DB	'   PRESS CTRL+X TO EXIT'
	DB      CH.CR,CH.LF,CH.EOT
	LD HL,	STR1		; Set up the printer
	LD B,	NSTR1
	CALL	TYPSTR
	LD C,	5               ; Set tab stops every 5
	LD D,	25              ; Set 25 of them
	LD A,	C		; First stop here
TCMDL1:	LD (STR4),A		; Fix up tab stop setting string
	LD HL,	STR3		; Now type the string to set a stop
	LD B,	NSTR3
	CALL	TYPSTR
	LD A,	5               ; Next tab stop here
	ADD A,	C		; ..
	LD C,	A
	DEC	D               ; Count them
	JR NZ,	TCMDL1		; Loop over tab stop setup
	LD A,	CH.CR           ; Now a return
	CALL	VSIOOU		; ..

	LD HL,	STR2		; More setup of printer
	LD B,	NSTR2           ; (who knows what all this does)
	CALL	TYPSTR

	LD A,	12              ; Set margin/column stuff starts at 12
	LD HL,	HPOS            ; Current horiz pos'n
	LD (HL),A		; ..
	INC	HL		; Point at left margin
	LD (HL),A		; LMARGN
	XOR	A		; Chars to not count HPOS for
	INC	HL		; ..
	LD (HL),A		; TYPGBL

TCMTYI:	CALL	VCONST		; Is keyboard ready?
	JR Z,	TCMTYI		; No, wait for it
	LD A,	(TYPGBL)        ; Chars to gobble, not counting HPOS
	SUB	1               ; 1 less to gobble
	ADC A,	0               ; Unless it was already 0, make 0
	LD (TYPGBL),A           ; Update gobble count
	CALL	VCONIN		; Get the keyboard char
	LD HL,	HPOS            ; Point HL at current horiz pos'n
	LD C,	A		; Hold a copy
	CP	CH.CTL		; Check for controls
	JP NC,	TCMNC		; Go if not a control
	CP	CH.CR		; Yes, filter which control it is
	JR NZ,	TCMXQ		; Go unless CR
	LD A,	(LMARGN)	; Copy LMARGN into HPOS on CR
	LD (HL),A		; ..
	LD HL,	STR5		; Type CRLF and fills
	LD B,	NSTR5
	CALL	TYPSTR
	JP	TCMTYI          ; Done carriage return

TCMXQ:	CP	CH.CAN          ; Control X?
	JP NZ,	TCMEQ		; No
	LD HL,	STR5		; Yes, type CRLF
	LD B,	NSTR5
	CALL	TYPSTR
	JP	VINIT           ; And reboot the machine

TCMEQ:	CP	CH.ESC          ; Escape?
	JR NZ,	TCMIQ		; Go if not
	LD A,	3               ; Yes, collect some args
	LD (TYPGBL),A           ; Gobble three more chars
	JP	TCMCCO		; Output the ESCape to printer

TCMIQ:	CP	CH.HT           ; Horiz tab?
	JR NZ,	TCMHQ		; Go if not
	LD IX,	TABLST		; Yes, find where it will wind up
	LD B,	(HL)		; get current column
TCMIL:	LD A,	(IX+0)          ; Compare with list of tabstops
	AND	A		; End of list?
	JR Z,	TCMBEL		; If so, suppress the tab
	INC	IX		; No, step thru list
	CP	B		; Beyond present column?
	JR C,	TCMIL		; No, look more
	JR Z,	TCMIL		; Ditto
	LD (HL),A		; Yes, make that the new current position
	JP	TCMCCO          ; Print the TAB

TCMBEL:	LD C,	CH.BEL          ; Type a bell on serial port
	JP	TCMCCO

TCMHQ:	CP	CH.BS           ; Backspace?
	JR NZ,	TCMCCO		; Go if not
	LD A,	(LMARGN)	; Are we at left margin?
	LD B,	A		; ..
	LD A,	(HL)		; ..
	CP	B		; ..
	JP Z,	TCMBEL		; If so, can't back up
	DEC	(HL)		; OK, back up HPOS
	JP	TCMCCO		; Output the backspace

; Not a control character.

TCMNC:	LD A,	(HL)            ; 132 chars?
	CP	132		; ..
	JP Z,	TCMBEL		; If so, too many
	LD A,	(TYPGBL)        ; Want to gobble any chars?
	AND	A		; ..
	JR Z,	TFA09		; Go if not
	LD A,	C		; Yes. What's this one?
	CP	'9'		; A nine?
	JP NZ,	TCMCCO		; Go if not
	LD A,	(HL)		; Yes, set left margin to current HPOS
	LD (LMARGN),A		; ..
	JP	TCMCCO		; Output the nine

TFA09:	INC	(HL)            ; Count characters
	JP	TCMCCO		; And output it to printer

TCMCCO:	LD A,	C		; Output char from kbd or special
	CALL	VSIOOU		; To the serial port
	JP	TCMTYI		; Get next char typed in

TYPSTR:	LD A,	(HL)		; Print a canned string
	CALL	VSIOOU		; On printer port
	INC	HL		; Step thru string
	DJNZ	TYPSTR		; And count chars
	RET

; Canned strings for printer control in typewriter mode

STR1:	DB	CH.ESC
	DB	CH.CR
	DB	'P'
	DB      0,0,0,0,0,0
NSTR1   EQU     $-STR1

STR2:   DB      CH.ESC,CH.HT,CH.FF,CH.ESC,'9'
NSTR2   EQU     $-STR2

STR3:   DB      0,0,0,0,0,CH.ESC,CH.HT
STR4:	DB	0
	DB      CH.ESC,'1',0,0,0,0,0
NSTR3   EQU     $-STR3

STR5:   DB      CH.CR,CH.LF,0,0,0,0,0,0,0
NSTR5   EQU     $-STR5

HPOS:	DB	12		; Current typewriter horizontal pos'n
LMARGN:	DB	12		; Current left margin of typewriter
TYPGBL:	DB	5		; Characters to not count position for

TABLST: DB      05,10,15,20,25,30,35,40,45,50
	DB      55,60,65,70,75,80,85,90,95,100
	DB      105,110,115,120,125,130,135,140,0

	DB	0,0,FF

	END			; End of second EPROM
