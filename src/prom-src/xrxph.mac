;
; Xerox 820 ROM-based monitor version 2.0, Disassembled by K1BC
;

	.Z80			; Use Zilog format ops
	INCLUDE	XRXPDEF		; Get the parameter assignments

; This program is copied from ROM to RAM at power clear. There is an LDIR
; at the beginning of the ROM which moves this code, then jumps to
; location F000.

; Start of the second EPROM. Appears at 10H below the page boundary at
; runtime because of the way it is copied out of the EPROMs.

; Linkage to the other PROM

	EXT	VASCHX		; Convert one ASCII char to hex (0-F)
	EXT	VCHOUT		; Output one character, with typein check
	EXT	VCONIN		; Console input
	EXT	VCONST		; Console status for keyboard
	EXT	VCRLFS		; Output a CR, LF and Space
	EXT	VCRTOU		; Output character to CRT
	EXT	VHDUMP		; Utility to dump an area in HEX
	EXT	VHOUSP		; Output one hex byte and a space
	EXT	VHWDOU		; Output a word in hex
	EXT	VINIT		; Prom monitor's cold restart
	EXT	VPSOUT		; Print string on output
	EXT	VSIOOU		; Output to the SIO port
	EXT	VTYIUC		; Type in a char, make it upper case

; Entries into this PROM needed by the low PROM

	ENTRY	CCMD, DCMD, FCMD, GCMD, MCMD, TCMD, VCMD, XCMD

	ASEG
	ORG	0800H

        .PHASE	0F7F0H		; Runs here, lives at byte 0 of the
				;  second EPROM, at 0800H in shadow

; First is a vector into the routines in this EPROM, so they can be
; developed separately.

DCMD:	JP	DCMD1
CCMD:	JP	CCMD1
MCMD:	JP	MCMD1
FCMD:	JP	FCMD1
XCMD:	JP	XCMD1
GCMD:	JP	GCMD1
VCMD:	JP	VCMD1
TCMD:	JP	TCMD1

; "D" command - dumps an area of memory

DCMD1:	DEC	A		; How many args?
	JR Z,	DCMD2		; Go if one, HL says where
	DEC	A		; Maybe two
	JR Z,	DCMD3		; Go if two
	LD HL,	(PRVADR)	; No args. Dump from previous address
DCMD2:	LD DE,	256/16		; Default is 256 bytes
	JR	DCMD5		; Go dump them

DCMD3:	EX DE,	HL		; Dump from arg1 thru arg2
	SBC HL, DE		; Compute length
	LD B,	4               ; Divide by 16
DCMD4:	SRL	H
	RR	L
	DJNZ	DCMD4
	INC	HL              ; Round up
	EX DE,	HL		; Args to HDUMP are set
DCMD5:	CALL	VHDUMP		; Call dumper in other ROM
	LD (PRVADR),HL          ; Update previous addr for next "D" command
	RET

; "M" command - modify memory at loc ARG1

MCMD1:	CALL	TYPADR		; Show location to be modified
	CALL	VTYIUC		; What does user say?
	CP	CH.CR           ; No change?
	JR Z,	MCMD4		; Yup
	CP	'-'		; Back up?
	JR Z,	MCMD5		; Yup
	CP	','		; Comma?
	JR NZ,	MCMD2		; No, probably hex
	CALL	VTYIUC		; For Comma, take next char and store it
	JR	MCMD3		; Go store

MCMD2:	CALL	VASCHX		; See if it's a hex char
	CCF			; Return bad if not
	RET	NC		; ..
	RLCA			; Yes, shift to high nibble
	RLCA
	RLCA
	RLCA
	LD C,	A		; Hold for a moment
	CALL	VTYIUC		; Get second hex char
	CALL	VASCHX		; Check it
	CCF			; Fail if not hex
	RET	NC		; ..
	OR	C		; Mix with first 4 bits
MCMD3:	LD (HL),A		; Store in memory
	CALL	MERROR		; Make sure it took
MCMD4:	INC	HL		; Step to next mem loc
	INC	HL		; ..
MCMD5:	DEC	HL		; Back up for "-" command
	JR	MCMD1		; See what's next

; "G" command - do a CALL to stated address

GCMD1:	DEC	A		; Must be one arg
	SCF			; Else don't do it
	RET	NZ		; ..
	PUSH	HL		; Move the addr to IX (for some reason)
	POP	IX		; ..
	CALL	GCMDGO		; Go to that addr
	OR	A		; It returned, so back to PROMPT
	RET			; with success flag

GCMDGO:	JP	(IX)		; Call user routine

; Memory exercisor, "X" command. Tests memory and types a "+" on the
; CRT after each pass. Two args, the low and high limits of memory to test.

XCMD1:	CP	2               ; Need two args for range to test
	SCF			; Fail if not
	RET	NZ		; ..
	INC	DE		; OK, set DE = first untested byte
	LD E,	D		; Ending page number
	LD D,	H		; Starting page number
	LD B,	0               ; XOR in a different number each pass
XCML1:	LD H,	D               ; Highbyte of starting test addr
	LD L,	0               ; Actually start at byte 0 of that page
XCML2:	LD A,	L		; Test data = adr hi xor adr lo xor pass
	XOR	H		; ..
	XOR	B               ; XOR in the pass number
	LD (HL),A		; Put it in ram
	INC	HL		; Step thru RAM
	LD A,	H		; Up to ending page?
	CP	E		; ..
	JR NZ,	XCML2		; No, keep on filling
	LD H,	D		; Yes, back to start of pattern
	LD L,	0
XCML3:	LD A,	L               ; Compute the same XOR
	XOR	H
	XOR	B
	CALL	MERROR          ; Check and report it
	RET	NZ              ; Quit if user types anything
	INC	HL		; Step through memory
	LD A,	H		; Check for end
	CP	E		; ..
	JR NZ,	XCML3		; Loop over whole test region
	INC	B		; Pass number for XORing
	LD A,	'+'             ; Pass indicator
	CALL	VCHOUT          ; Type the plus
	JR Z,	XCML1           ; Unless banging on kbd, loop
	RET			; Quit. Someone typed.

MERROR:	CP	(HL)		; If modification worked,
	RET	Z		; Return OK
	PUSH	AF		; Else complain
	CALL	TYPADR          ; Show where it failed
	CALL	VPSOUT		; say it failed
	DB	'should=',CH.EOT
	POP	AF		; What it should be
	CALL	VHOUSP		; ..
	RET

TYPADR:	CALL	VCRLFS		; New line and space
	CALL	VHWDOU		; Output the address from HL
	LD A,	(HL)		; Pick up what's in memory
	CALL	VHOUSP		; Show that, space.
	RET

; "F" command - Fill memory with a value

FCMD1:	CP	3               ; Need three args
	SCF			; Fail if not
	RET	NZ		; ..
FCMD2:	LD (HL),C		; Fill a byte
	PUSH	HL		; Check for end
	OR	A
	SBC HL, DE
	POP	HL
	INC	HL		; On to next byte
	JR C,	FCMD2		; Loop unless done
	RET

; "C" command - Copy Fromfirst, Fromlast, Tofirst

CCMD1:	CP	3               ; Three args needed
	SCF			; ..
	RET	NZ		; Fail if not
	CALL	ARGADJ		; Fiddle the three args for loop
	LD A,	C		; Is length zero?
	OR	B		; ..
	RET	Z		; If so, don't move 64K
	LDIR			; OK, move it!
	RET

ARGADJ:	EX DE,	HL		; Adjust args for LDIR and CPIR
	OR	A		; Clear CY
	SBC HL, DE		; Get count from first/last
	EX DE,	HL		; DE = count, actually minus 1
	PUSH	DE		; Shuffle them around
	PUSH	BC		; ..
	POP	DE		; Here's destination
	POP	BC		; Here's count -1
	INC	BC		; Make it Count
	RET			; And HL has First source

; "V" command - verify one area against another. Args as in "C" command

VCMD1:	CP	3               ; Need three args
	SCF			; Fail if not
	RET	NZ		; ..
	CALL	ARGADJ		; Adjust args for compare loop
	JR	VCMD3		; End test first in case length zero

VCMD2:	LD A,	(DE)		; Pick up one region's byte
	CALL	MERROR		; Check and report if different
	RET	NZ		; Return if user types.
	INC	HL		; Step both pointers
	INC	DE		; ..
	DEC	BC		; and count
VCMD3:	LD A,	B		; End check
	OR	C		; Is count now zero?
	JR NZ,	VCMD2		; No, keep verifying
	RET

; "T" command - expensive typewriter, copies from keyboard to
; printer. An arg is the baud rate code for printer.

TCMD1:	LD A,	L		; Check for an argument
	AND	0FH		; ..
	JR NZ,	TCMD2		; Use it if any
	LD A,	7               ; If none, use 1200 baud
TCMD2:	OUT (BRG.B),A           ; Choose baud rate for SIO B
	LD A,	CH.SUB          ; Clear CRT screen
	CALL	VCRTOU		; ..
	CALL	VPSOUT		; Announce typewriter mode
	DB	'...820 TYPEWRITER  VER. 1.0...'
	DB      CH.CR,CH.LF
	DB	'   PRESS CTRL+X TO EXIT'
	DB      CH.CR,CH.LF,CH.EOT
	LD HL,	STR1		; Set up the printer
	LD B,	NSTR1
	CALL	TYPSTR
	LD C,	5               ; Set tab stops every 5
	LD D,	25              ; Set 25 of them
	LD A,	C		; First stop here
TCMDL1:	LD (STR4),A		; Fix up tab stop setting string
	LD HL,	STR3		; Now type the string to set a stop
	LD B,	NSTR3
	CALL	TYPSTR
	LD A,	5               ; Next tab stop here
	ADD A,	C		; ..
	LD C,	A
	DEC	D               ; Count them
	JR NZ,	TCMDL1		; Loop over tab stop setup
	LD A,	CH.CR           ; Now a return
	CALL	VSIOOU		; ..

	LD HL,	STR2		; More setup of printer
	LD B,	NSTR2           ; (who knows what all this does)
	CALL	TYPSTR

	LD A,	12              ; Set margin/column stuff starts at 12
	LD HL,	HPOS            ; Current horiz pos'n
	LD (HL),A		; ..
	INC	HL		; Point at left margin
	LD (HL),A		; LMARGN
	XOR	A		; Chars to not count HPOS for
	INC	HL		; ..
	LD (HL),A		; TYPGBL

TCMTYI:	CALL	VCONST		; Is keyboard ready?
	JR Z,	TCMTYI		; No, wait for it
	LD A,	(TYPGBL)        ; Chars to gobble, not counting HPOS
	SUB	1               ; 1 less to gobble
	ADC A,	0               ; Unless it was already 0, make 0
	LD (TYPGBL),A           ; Update gobble count
	CALL	VCONIN		; Get the keyboard char
	LD HL,	HPOS            ; Point HL at current horiz pos'n
	LD C,	A		; Hold a copy
	CP	CH.CTL		; Check for controls
	JP NC,	TCMNC		; Go if not a control
	CP	CH.CR		; Yes, filter which control it is
	JR NZ,	TCMXQ		; Go unless CR
	LD A,	(LMARGN)	; Copy LMARGN into HPOS on CR
	LD (HL),A		; ..
	LD HL,	STR5		; Type CRLF and fills
	LD B,	NSTR5
	CALL	TYPSTR
	JP	TCMTYI          ; Done carriage return

TCMXQ:	CP	CH.CAN          ; Control X?
	JP NZ,	TCMEQ		; No
	LD HL,	STR5		; Yes, type CRLF
	LD B,	NSTR5
	CALL	TYPSTR
	JP	VINIT           ; And reboot the machine

TCMEQ:	CP	CH.ESC          ; Escape?
	JR NZ,	TCMIQ		; Go if not
	LD A,	3               ; Yes, collect some args
	LD (TYPGBL),A           ; Gobble three more chars
	JP	TCMCCO		; Output the ESCape to printer

TCMIQ:	CP	CH.HT           ; Horiz tab?
	JR NZ,	TCMHQ		; Go if not
	LD IX,	TABLST		; Yes, find where it will wind up
	LD B,	(HL)		; get current column
TCMIL:	LD A,	(IX+0)          ; Compare with list of tabstops
	AND	A		; End of list?
	JR Z,	TCMBEL		; If so, suppress the tab
	INC	IX		; No, step thru list
	CP	B		; Beyond present column?
	JR C,	TCMIL		; No, look more
	JR Z,	TCMIL		; Ditto
	LD (HL),A		; Yes, make that the new current position
	JP	TCMCCO          ; Print the TAB

TCMBEL:	LD C,	CH.BEL          ; Type a bell on serial port
	JP	TCMCCO

TCMHQ:	CP	CH.BS           ; Backspace?
	JR NZ,	TCMCCO		; Go if not
	LD A,	(LMARGN)	; Are we at left margin?
	LD B,	A		; ..
	LD A,	(HL)		; ..
	CP	B		; ..
	JP Z,	TCMBEL		; If so, can't back up
	DEC	(HL)		; OK, back up HPOS
	JP	TCMCCO		; Output the backspace

; Not a control character.

TCMNC:	LD A,	(HL)            ; 132 chars?
	CP	132		; ..
	JP Z,	TCMBEL		; If so, too many
	LD A,	(TYPGBL)        ; Want to gobble any chars?
	AND	A		; ..
	JR Z,	TFA09		; Go if not
	LD A,	C		; Yes. What's this one?
	CP	'9'		; A nine?
	JP NZ,	TCMCCO		; Go if not
	LD A,	(HL)		; Yes, set left margin to current HPOS
	LD (LMARGN),A		; ..
	JP	TCMCCO		; Output the nine

TFA09:	INC	(HL)            ; Count characters
	JP	TCMCCO		; And output it to printer

TCMCCO:	LD A,	C		; Output char from kbd or special
	CALL	VSIOOU		; To the serial port
	JP	TCMTYI		; Get next char typed in

TYPSTR:	LD A,	(HL)		; Print a canned string
	CALL	VSIOOU		; On printer port
	INC	HL		; Step thru string
	DJNZ	TYPSTR		; And count chars
	RET

; Canned strings for printer control in typewriter mode

STR1:	DB	CH.ESC
	DB	CH.CR
	DB	'P'
	DB      0,0,0,0,0,0
NSTR1   EQU     $-STR1

STR2:   DB      CH.ESC,CH.HT,CH.FF,CH.ESC,'9'
NSTR2   EQU     $-STR2

STR3:   DB      0,0,0,0,0,CH.ESC,CH.HT
STR4:	DB	0
	DB      CH.ESC,'1',0,0,0,0,0
NSTR3   EQU     $-STR3

STR5:   DB      CH.CR,CH.LF,0,0,0,0,0,0,0
NSTR5   EQU     $-STR5

HPOS:	DB	12		; Current typewriter horizontal pos'n
LMARGN:	DB	12		; Current left margin of typewriter
TYPGBL:	DB	5		; Characters to not count position for

TABLST: DB      05,10,15,20,25,30,35,40,45,50
	DB      55,60,65,70,75,80,85,90,95,100
	DB      105,110,115,120,125,130,135,140,0

	DB	0,0,FF

	END			; End of second EPROM
